<div class="page-header">
  <h1 class="title">SampleTime</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/sampleTime" target="_blank" rel="noopener">rxjs sampleTime
    â¡ï¸</a>
</div>

<p>
  Este operador mira cada cierto tiempo el Observable fuente y emite el Ãºltimo elemento que se se haya emitido hasta
  ese momento desde la Ãºltima vez que mirÃ³.
</p>


<textarea highlight-js [lang]="'typescript'">
import { Observable, sampleTime } from 'rxjs';

new Observable((suscriptor) => {
  setTimeout(() => suscriptor.next('ğŸ'), 200);
  setTimeout(() => suscriptor.next('ğŸŒ'), 300);
  setTimeout(() => suscriptor.next('ğŸ“'), 1100);
  setTimeout(() => suscriptor.next('ğŸŠ'), 1200);
})
  .pipe(sampleTime(500))
  .subscribe({
    next: (value) => console.log(`The next value is: ${value}`),
    error: (error) => console.error(`There is an error: ${error}`),
    complete: () => console.log('Completed'),
  });

// Output
// The next value is: ğŸŒ
// The next value is: ğŸŠ
</textarea>

<p>
  Como siempre, vamos a explicar el ejemplo. El operador estÃ¡ configurado para mirar el Observable fuente cada medio
  segundo, y empieza a mirar desde el momento en el que se suscribe.
</p>

<p>
  Primero se emite la ğŸ a los 200 milisegundos. El operador lo retiene hasta que llegue el momento en el que tiene
  que mirar el Observable fuente. DespuÃ©s de 100 milisegundos mÃ¡s se emite el ğŸŒ. El operador lo retiene tambiÃ©n y
  descarta la ğŸ. Finalmente pasan otros 200 milisegundos y llega el momento del operador. Lo Ãºltimo que se emitiÃ³ fue
  el ğŸŒ, asÃ­ que lo emite al suscriptor. Pasan otros 500 milisegundos y el operador vuelve a mirar el Observable
  fuente. Como no se ha emitido nada desde la Ãºltima vez que mirÃ³, el operador no hace nada. Luego pasan 100
  milisegundos y se emite la ğŸ“. El operador la retiene hasta que le llegue el momento de mirar de nuevo. Pasan otros
  100 milisegundos y se emite la ğŸŠ. El operador descarta la ğŸ“ y guarda la ğŸŠ. Cuando pasan otros 300 milisegundos el
  operador mira y ve que lo Ãºltimo que se emitio fue la ğŸŠ, asi que la emite al suscriptor.
</p>

<p>BÃ¡sicamente sampleTime nos limita a como mÃ¡ximo uno, el nÃºmero de elementos emitidos el intervalo que le digamos.</p>

<p>PruÃ©balo tÃº mismo en esta demo donde el operador mira cada 3ï¸âƒ£ segundos:</p>

<svg appDemoContainer viewBox="0 0 640 240">
  <g transform="translate(30, 80)" appConveyorController [button1]="controllerButtons[MAIN_ID][0]"
    [button2]="controllerButtons[MAIN_ID][1]" [button3]="controllerButtons[MAIN_ID][2]"
    [button4]="controllerButtons[MAIN_ID][3]" [button5]="controllerButtons[MAIN_ID][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <g transform="translate(220, 80)" appConveyorHorizontal [conveyorWorking$]="conveyorsWorking[MAIN_ID]"
    [length]="250.8">
  </g>

  <g appOperator transform="translate(295, 45)"></g>

  <text x="337" y="110" fill="white" text-anchor="middle" font-size="0.8em">{{getCounterValue()}}s</text>

  <g transform="translate(496, 20)" appSubscriber [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)">
  </g>

  <g>
    <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x" y="136">{{element.value}}</text>
    <text x="300" y="136">{{elementInStandBy}}</text>
  </g>
</svg>