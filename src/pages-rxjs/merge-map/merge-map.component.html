<div class="page-header">
  <h1>MergeMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/mergeMap" target="_blank">rxjs mergeMap ‚û°Ô∏è</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve un nuevo Observable por
  cada elemento, cuyos elementos emitidos ser√°n puestos de nuevo en el observable fuente y que ser√°n los que se entregen
  al subscriptor.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, mergeMap } from 'rxjs';

// This is the source observable
const numbers$ = new Observable<number>((observer) => {
  observer.next(2);
  observer.next(3);
  observer.next(0);
  observer.next(4);
});

// use the pipe method to add operators
numbers$
  .pipe(
    mergeMap(
      (number) =>
        new Observable((observer) => {
          if (number === 0) {
            observer.error('No existences');
          } else {
            observer.next('üçé'.repeat(number));
            observer.complete();
          }
        })
    )
  )
  .subscribe(
    (value) => console.log(`The next value is: ${value}`),
    (error) => console.error(`There is an error: ${error}`)
  );

// Output
// ======
// The next value is: üçéüçé
// The next value is: üçéüçéüçé
// There is an error: No existences
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite n√∫meros, y por cada n√∫mero tenemos otro observable que nos emite
  tantas manzanas como diga ese n√∫mero. En el momento que hay un error en cualquiera de los Observables este se emite al
  subscriptor.
</p>

<p>
  En este caso tan sencillo los elementos se emiten de forma s√≠ncrona, pero cuando hacemos alguna llamada real a alg√∫n
  servidor podr√≠a emitir en otro orden, es decir, el Observable fuente pide primero dos manzanas y el Observable del
  mergeMap las emite inmediatamente, pero en una llamada real esto quedar√≠a a la espera y se emitir√≠a el n√∫mero tres,
  pudiendo resolverse antes y entregando antes las tres manzanas que las dos que estamos esperando.
</p>

<p>
  A continuaci√≥n te dejo un simulador para que pruebes:
</p>

<app-demo-container class="demo-container">
  <app-conveyor-controller class="main-conveyor-controller" [button1]="{value: 'üöó', type: ObservableEventType.ERROR}"
    [button2]="{value: 'üñêÔ∏è', type: ObservableEventType.COMPLETE}"
    [button3]="{value: '1Ô∏è‚É£', type: ObservableEventType.NEXT}"
    [button4]="{value: '2Ô∏è‚É£', type: ObservableEventType.NEXT}"
    [button5]="{value: '3Ô∏è‚É£', type: ObservableEventType.NEXT}" (onButtonClick)="onMainControllerButtonClick($event)">
  </app-conveyor-controller>

  <div class="conveyors-container">
    <div class="mergemap-conveyors-container">
      <div class="merge-map-conveyor-and-controller" *ngFor="let observable of mergeMapObservables; let i = index"
        [@observableAnimation]>
        <app-conveyor-controller class="merge-map-conveyor-controller"
          [button1]="{value: 'üöó', type: ObservableEventType.ERROR}"
          [button3]="{value: 'üñêÔ∏è', type: ObservableEventType.COMPLETE}"
          [button4]="{value: observable.value, type: ObservableEventType.NEXT}"
          (onButtonClick)="onMergeMapControllerButtonClick($event, i)">
        </app-conveyor-controller>

        <app-conveyor-vertical class="merge-map-conveyor" [conveyorWorking$]="observable.conveyorWorking$"
          [addToConveyor$]="observable.addToConveyor$" (elementDelivered)="onMergeMapElementDelivered($event, i)">
        </app-conveyor-vertical>
      </div>
    </div>

    <app-conveyor-horizontal class="main-conveyor" [length]="499.5" [conveyorWorking$]="mainConveyorWorking$"
      [addToConveyor$]="addToMainConveyor$" (elementDelivered)="onMainElementDelivered($event)">
    </app-conveyor-horizontal>
  </div>

  <app-subscriber class="subscriber" [showSpeechBubble$]="speechBubble$" (onSubscribe$)="onSubscribe($event)">
  </app-subscriber>
</app-demo-container>