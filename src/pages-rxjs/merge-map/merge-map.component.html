<div class="page-header">
  <h1>MergeMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/mergeMap" target="_blank">rxjs mergeMap â¡ï¸</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve un nuevo Observable por
  cada elemento, cuyos elementos emitidos serÃ¡n puestos de nuevo en el observable fuente y que serÃ¡n los que se entregen
  al subscriptor.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, mergeMap } from 'rxjs';

// This is the source observable
const numbers$ = new Observable<number>((observer) => {
  observer.next(2);
  observer.next(3);
  observer.next(0);
  observer.next(4);
});

// use the pipe method to add operators
numbers$
  .pipe(
    mergeMap(
      (number) =>
        new Observable((observer) => {
          if (number === 0) {
            observer.error('No existences');
          } else {
            observer.next('ğŸ'.repeat(number));
            observer.complete();
          }
        })
    )
  )
  .subscribe(
    (value) => console.log(`The next value is: ${value}`),
    (error) => console.error(`There is an error: ${error}`)
  );

// Output
// ======
// The next value is: ğŸğŸ
// The next value is: ğŸğŸğŸ
// There is an error: No existences
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite nÃºmeros, y por cada nÃºmero tenemos otro observable que nos emite
  tantas manzanas como diga ese nÃºmero. En el momento que hay un error en cualquiera de los Observables este se emite al
  subscriptor.
</p>

<p>
  En este caso tan sencillo los elementos se emiten de forma sÃ­ncrona, pero cuando hacemos alguna llamada real a algÃºn
  servidor podrÃ­a emitir en otro orden, es decir, el Observable fuente pide primero dos manzanas y el Observable del
  mergeMap las emite inmediatamente, pero en una llamada real esto quedarÃ­a a la espera y se emitirÃ­a el nÃºmero tres,
  pudiendo resolverse antes y entregando antes las tres manzanas que las dos que estamos esperando.
</p>

<p>
  A continuaciÃ³n te dejo un simulador para que pruebes:
</p>

<div class="demo-container">
  <app-conveyor-controller class="main-conveyor-controller" (onClickNext)="onClickMainNext()"
    (onClickError)="onClickMainError()" (onClickComplete)="onClickMainComplete()">
    <ng-container ngProjectAs="[next]">{{applesToEmit}}</ng-container>
    <ng-container ngProjectAs="[error]">ğŸŒ</ng-container>
    <ng-container ngProjectAs="[complete]">ğŸ–ï¸</ng-container>
  </app-conveyor-controller>

  <div class="conveyors-container">
    <div class="mergemap-conveyors-container">
      <div class="merge-map-conveyor-and-controller" *ngFor="let observable of mergeMapObservables; let i = index"
        [@observableAnimation]>
        <app-conveyor-controller class="merge-map-conveyor-controller" (onClickNext)="onClickMergeMapNext(i)"
          (onClickError)="onClickMergeMapError(i)" (onClickComplete)="onClickMergeMapComplete(i)">
          <ng-container ngProjectAs="[next]">{{'ğŸ'.repeat(observable.value == '2ï¸âƒ£' ? 2 : 1)}}</ng-container>
          <ng-container ngProjectAs="[error]">ğŸŒ</ng-container>
          <ng-container ngProjectAs="[complete]">ğŸ–ï¸</ng-container>
        </app-conveyor-controller>

        <app-conveyor-vertical class="merge-map-conveyor" [conveyorWorking$]="observable.conveyorWorking$"
          [addToConveyor$]="observable.addToConveyor$" (elementDelivered)="onMergeMapElementDelivered(i, $event)">
        </app-conveyor-vertical>
      </div>
    </div>

    <app-conveyor class="main-conveyor" [length]="499.5" [conveyorWorking$]="mainConveyorWorking$"
      [addToConveyor$]="addToMainConveyor$" (elementDelivered)="onMainElementDelivered($event)">
    </app-conveyor>
  </div>

  <app-subscriber class="subscriber" [showSpeechBubble$]="speechBubble$" (onSubscribe$)="onSubscribe($event)">
  </app-subscriber>
</div>