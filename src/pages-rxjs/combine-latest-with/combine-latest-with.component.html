<div class="page-header">
  <h1 class="title">CombineLatestWith</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/combineLatestWith" target="_blank" rel="noopener">rxjs combineLatestWith
    â¡ï¸</a>
</div>

<p>
  Este operador crea un nuevo Observable que combina en un array los Ãºltimos elementos emitidos por el Observable fuente
  y los Observables pasados como argumentos, siempre que todos los Observables hayan emitido al menos un elemento.
</p>

<textarea highlight-js [lang]="'typescript'">
import { combineLatestWith, Observable } from 'rxjs';

const observable1 = new Observable((subscriber) => {
  setTimeout(() => subscriber.next('ğŸ'), 100);
  setTimeout(() => subscriber.next('ğŸŒ'), 200);
  setTimeout(() => subscriber.complete(), 600);
});

const observable2 = new Observable((subscriber) => {
  setTimeout(() => subscriber.next('ğŸ'), 300);
  setTimeout(() => subscriber.next('ğŸ'), 800);
  setTimeout(() => subscriber.complete(), 900);
});

const source$ = new Observable((subscriber) => {
  setTimeout(() => subscriber.next('ğŸ“'), 400);
  setTimeout(() => subscriber.next('ğŸ‰'), 500);
  setTimeout(() => subscriber.complete(), 700);
});

source$.pipe(
  combineLatestWith(observable1, observable2),
).subscribe({
  next: (value) => console.log('Next', value),
  error: (error) => console.log('Error', error),
  complete: () => console.log('Completed'),
});

// Output
// Next ['ğŸ“', 'ğŸŒ', 'ğŸ']
// Next ['ğŸ‰', 'ğŸŒ', 'ğŸ']
// Next ['ğŸ‰', 'ğŸŒ', 'ğŸ']
// Complete
</textarea>

<p>
  Voy a explicar el ejemplo.
</p>

<p>
  Tenemos dos Observables que pasamos como argumentos al operador y el Observable fuente. Al suscribirnos al Observable
  fuente el operador se suscribe tambiÃ©n a los dos Observables que le pasamos. Ahora independientemente de que
  Obsevable emita, se emitirÃ¡ un nuevo elemento en forma de array al suscriptor con el Ãºltimo elemento que cada
  Observable haya emitido, siempre y cuando todos los Observables hayan emitido al menos un elemento ya.
</p>

<p>
  Por lo tanto, el observable1 emite una ğŸ. Como los demÃ¡s Observables no han emitido nada aÃºn no se emite nada al
  suscriptor. El observable1 vuelve a emitir un ğŸŒ. Como los demÃ¡s Observables no han emitido nada aÃºn no se emite
  nada al suscriptor. El observable2 emite una ğŸ. Como el Observable fuente aÃºn queda por emitir no se emite nada al
  suscriptor. El Obsevable fuente emite una ğŸ“. Como todos los Observables han emitido un elemento ya, se entrega al
  suscriptor un array <span class="no-break">['ğŸ“', 'ğŸŒ', 'ğŸ']</span> con los Ãºltimos elementos de cada Observable. El
  Observable fuente emite una ğŸ‰. Por tanto se emite al suscriptor de nuevo los Ãºltimos elementos de cada Observable
  <span class="no-break">['ğŸ‰', 'ğŸŒ', 'ğŸ']</span>. DespuÃ©s el observable2 emite una ğŸ y se emite al suscriptor un
  nuevo array <span class="no-break">['ğŸ‰', 'ğŸŒ', 'ğŸ']</span>.
</p>

<p>
  Una cosa a tener en cuenta es que el Observable al que se suscribe el suscriptor solo completa cuando todos los
  Observables han completado. Si alguno de los Observables completa y otro emite un elemento, todavÃ­a se entregarÃ¡ un
  array al suscriptor, incluyendo tambiÃ©n el Ãºltimo elemento de los Observables que ya han completado.
</p>

<p>
  A continuaciÃ³n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 900 600">
  <!-- main conveyor left controller -->
  <g appConveyorController transform="translate(45,400)" [button1]="controllerButtons[MAIN_ID][0]"
    [button2]="controllerButtons[MAIN_ID][1]" [button3]="controllerButtons[MAIN_ID][2]"
    [button4]="controllerButtons[MAIN_ID][3]" [button5]="controllerButtons[MAIN_ID][4]"
    (onButtonClick)="onControllerButtonClick($event)"></g>

  <!-- main conveyor left -->
  <g appConveyorHorizontal transform="translate(240,430)" [length]="230.5"
    [conveyorWorking$]="conveyorsWorking[MAIN_ID[0]]">
  </g>

  <!-- left combineLatestWith conveyor controller -->
  <g appConveyorController transform="translate(290,35)" [button1]="controllerButtons[COMBINELATESTWITH[0]][0]"
    [button2]="controllerButtons[COMBINELATESTWITH[0]][1]" [button3]="controllerButtons[COMBINELATESTWITH[0]][2]"
    [button4]="controllerButtons[COMBINELATESTWITH[0]][3]" [button5]="controllerButtons[COMBINELATESTWITH[0]][4]"
    (onButtonClick)="onControllerButtonClick($event)"></g>

  <!-- left combineLatestWith conveyor -->
  <g appConveyorVertical transform="translate(335,155)" [conveyorWorking$]="conveyorsWorking[COMBINELATESTWITH[0]]"></g>

  <g appOperator transform="translate(435,390)"></g>

  <!-- right combineLatestWith conveyor controller -->
  <g appConveyorController transform="translate(480,35)" [button1]="controllerButtons[COMBINELATESTWITH[1]][0]"
    [button2]="controllerButtons[COMBINELATESTWITH[1]][1]" [button3]="controllerButtons[COMBINELATESTWITH[1]][2]"
    [button4]="controllerButtons[COMBINELATESTWITH[1]][3]" [button5]="controllerButtons[COMBINELATESTWITH[1]][4]"
    (onButtonClick)="onControllerButtonClick($event)"></g>

  <!-- right combineLatestWith conveyor -->
  <g appConveyorVertical transform="translate(525,155)" [conveyorWorking$]="conveyorsWorking[COMBINELATESTWITH[1]]"></g>

  <!-- main conveyor right -->
  <g appConveyorHorizontal transform="translate(480,430)" [length]="230.5"
    [conveyorWorking$]="conveyorsWorking[COMBINELATESTWITH[2]]">
  </g>

  <!-- subscriber -->
  <g appSubscriber transform="translate(750,375)" [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)"></g>

  <g>
    <text *ngFor="let element of elementsInStandby" [attr.x]="element.x" [attr.y]="element.y">{{element.value}}</text>
    <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x" [attr.y]="element.y">{{element.value}}</text>
  </g>
</svg>