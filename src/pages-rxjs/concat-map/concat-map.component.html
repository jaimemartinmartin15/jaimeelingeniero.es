<div class="page-header">
  <h1 class="title">ConcatMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/concatMap" target="_blank" rel="noopener">rxjs concatMap
    â¡ï¸</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve, por orden, un nuevo
  Observable por cada elemento. Es decir, hasta que no se completa el nuevo Observable, no crea uno nuevo para el
  siguiente elemento en el Observable fuente. Los elementos del nuevo Observable son puestos en el Obsevable fuente
  y son entregados al suscriptor.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, concatMap } from 'rxjs';

// This is the source observable
const hearts$ = new Observable<string>((subscriber) => {
  subscriber.next('ğŸ’œ');
  setTimeout(() => subscriber.next('ğŸ’š'), 100);
  setTimeout(() => subscriber.next('â¤ï¸'), 200);
  setTimeout(() => subscriber.next('ğŸ˜ï¸'), 300);
});

// Use the pipe method to add operators
hearts$
  .pipe(
    concatMap(
      (heart) =>
        new Observable((subscriber) => {
          if (heart === 'ğŸ’œ') {
            setTimeout(() => {
              subscriber.next('ğŸ‡');
              subscriber.complete();
            }, 150);
          } else if (heart === 'ğŸ’š') {
            subscriber.next('ğŸ');
            subscriber.complete();
          } else if (heart === 'â¤ï¸') {
            setTimeout(() => {
              subscriber.next('ğŸ“');
              subscriber.complete();
            }, 150);
          } else {
            subscriber.error(`No heart value: ${heart}`);
          }
        })
    )
  )
  .subscribe({
    next: (value) => console.log(`The next value is: ${value}`),
    error: (error) => console.error(`There is an error: ${error}`),
    complete: () => console.log('Completed'),
  });

// Output
// ======
// The next value is: ğŸ‡
// The next value is: ğŸ
// The next value is: ğŸ“
// There is an error: No heart value: ğŸ˜ï¸
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite corazones de colores, y por cada corazÃ³n tenemos otro observable que
  nos emite una fruta del mismo color que el corazÃ³n. En el momento que hay un error en cualquiera de los Observables
  este se emite al suscriptor y todos los Observables pendientes se cancelan.
</p>

<p>
  Ahora veamos los detalles. Primero se emite el ğŸ’œ. Este crearÃ¡ un Observable que emitirÃ¡ unas ğŸ‡ pasados 150
  milisegundos. Pasados 100 milisegundos, se emite el ğŸ’š. Como el Observable del ğŸ’œ aÃºn no ha completado, se retrasa la
  creaciÃ³n del Observable para el ğŸ’š. Pasan entonces 50 milisegundos y se emiten las ğŸ‡ y se completa el Observable. En
  ese momento el Observable del ğŸ’š esta pendiente, asÃ­ que se subscribe a Ã©l y emite inmediatamente una ğŸ y completa.
  Pasan 50 milisegundos mÃ¡s y se emite el â¤ï¸, que emitirÃ¡ pasados 150 milisegundos una ğŸ“. Pasan 100 milisegundos y se
  emite la ğŸ˜ï¸. Como el Observable del â¤ï¸ aÃºn no ha completado, se retrasa la creaciÃ³n del nuevo Observable. Pasan 50
  milisegundos mÃ¡s y se emite la ğŸ“ y completa. El Observable pendiente de la ğŸ˜ï¸ entonces emite ahora el error.
</p>

<p>
  A continuaciÃ³n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 850 640">
  <!-- main conveyor controller -->
  <g appConveyorController transform="translate(50,490)" [button1]="controllerButtons[MAIN_ID][0]"
    [button2]="controllerButtons[MAIN_ID][1]" [button3]="controllerButtons[MAIN_ID][2]"
    [button4]="controllerButtons[MAIN_ID][3]" [button5]="controllerButtons[MAIN_ID][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <!-- main conveyor -->
  <g transform="translate(260, 490)" appConveyorHorizontal [length]="403"
    [conveyorWorking$]="conveyorsWorking[MAIN_ID]">
  </g>

  <!-- operator -->
  <g appOperator transform="translate(420, 452)"></g>

  <!-- operator conveyor and controllers -->
  <g [attr.transform]="'translate('+(460 - (200*CONCATMAP.length/2))+', 70)'" class="smooth-tranform-animation">
    <g [attr.transform]="'translate('+200*i+',0)'" *ngFor="let C_ID of CONCATMAP; let i = index;" @fadeInOut
      class="smooth-tranform-animation">

      <!-- operator conveyor controller -->
      <g appConveyorController [attr.transform]="'translate(25,0)'" [button1]="controllerButtons[C_ID][0]"
        [button2]="controllerButtons[C_ID][1]" [button3]="controllerButtons[C_ID][2]"
        [button4]="controllerButtons[C_ID][3]" [button5]="controllerButtons[C_ID][4]"
        (onButtonClick)="onControllerButtonClick($event)">
      </g>

      <!-- operator conveyor -->
      <g [attr.transform]="'translate(70, 120)'" appConveyorVertical [length]="203"
        [conveyorWorking$]="conveyorsWorking[C_ID]">
      </g>

      <!-- elements in operator conveyor -->
      <g>
        <ng-container *ngFor="let element of elementsInConveyor">
          <text *ngIf="element.conveyorId === C_ID" x="90" [attr.y]="element.y">{{element.value}}</text>
        </ng-container>
      </g>
    </g>
  </g>

  <!-- subscriber -->
  <g appSubscriber transform="translate(690,420)" [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)"></g>

  <!-- elements in main conveyor -->
  <g>
    <ng-container *ngFor="let element of elementsInConveyor">
      <text *ngIf="element.conveyorId === MAIN_ID" [attr.x]="element.x" y="546">{{element.value}}</text>
    </ng-container>
  </g>
</svg>