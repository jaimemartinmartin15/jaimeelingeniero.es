<div class="page-header">
  <h1 class="title">AuditTime</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/auditTime" target="_blank" rel="noopener">rxjs auditTime â¡ï¸</a>
</div>

<p>
  Este operador espera a que se emita un elemento en el Observable fuente. A continuaciÃ³n inicia un temporizador, y
  cuando termina, emite el Ãºltimo elemento que haya pasado en el Observable fuente. A continuaciÃ³n espera el siguiente
  elemento y repite el proceso.
</p>

<textarea highlight-js [lang]="'typescript'">
import { auditTime, Observable } from 'rxjs';

new Observable((suscriptor) => {
  setTimeout(() => suscriptor.next('ğŸ'), 10);
  setTimeout(() => suscriptor.next('ğŸŒ'), 100);
  setTimeout(() => suscriptor.next('ğŸ¥’'), 250);
  setTimeout(() => suscriptor.next('ğŸ‡'), 280);
  setTimeout(() => suscriptor.next('ğŸ‹'), 320);
  setTimeout(() => suscriptor.next('ğŸ'), 380);
  setTimeout(() => suscriptor.next('ğŸ“'), 390);
  setTimeout(() => suscriptor.complete(), 400);
})
  .pipe(auditTime(100))
  .subscribe({
    next: (value) => console.log(`The next value is: ${value}`),
    error: (error) => console.error(`There is an error: ${error}`),
    complete: () => console.log('Completed'),
  });

// Output
// The next value is: ğŸŒ
// The next value is: ğŸ‹
// The next value is: ğŸ“
// Completed
</textarea>

<p>
  Expliquemos el ejemplo. Primero se emite una ğŸ a los 10 milisegundos. En este momento comienza el temporizador del
  operador. DespuÃ©s se emite el ğŸŒ pasados 90 milisegundos mÃ¡s. Por lo tanto la ğŸ se ignora y cuando el temporizador
  del operador llegue a cero se emitirÃ¡ el ğŸŒ. Esto pasa 10 milisegundos mÃ¡s tarde, y el operador emite el ğŸŒ en el
  milisegundo 110 de los totales. DespuÃ©s pasan 140 milisegundos sin mÃ¡s hasta que se emite el ğŸ¥’. El operador vuelve a
  iniciar su temporizador a 100 milisegundos. Se emiten unas ğŸ‡ 30 milisegundos despuÃ©s, y tambiÃ©n un ğŸ‹ 40 milisegundos
  mÃ¡s tarde. Pasan 30 milisegundos mÃ¡s y el temporizador llega a cero en el milisegundo 350 de los totales. Como lo
  Ãºltimo que se emitiÃ³ fue el ğŸ‹ el operador lo emite. Pasan entoces 60 milisegundos sin mÃ¡s hasta que se emite la ğŸ.
  El operador comienza su temporizado de nuevo. Se emite tambiÃ©n una ğŸ“ 10 milisegundos despuÃ©s. Al temporizador del
  operador le quedan 90 milisegundos para volver a emitir. Pero como el Observable completa antes, se emite
  inmediatamente la ğŸ“ al subscriptor.
</p>

<p>PruÃ©balo en esta demo, donde el valor del temporizador es de 3ï¸âƒ£ segundos:</p>

<svg appDemoContainer viewBox="0 0 640 240">
  <g transform="translate(30, 80)" appConveyorController [button1]="controllerButtons[MAIN_ID][0]"
    [button2]="controllerButtons[MAIN_ID][1]" [button3]="controllerButtons[MAIN_ID][2]"
    [button4]="controllerButtons[MAIN_ID][3]" [button5]="controllerButtons[MAIN_ID][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <g transform="translate(220, 80)" appConveyorHorizontal [conveyorWorking$]="conveyorsWorking[MAIN_ID]"
    [length]="250.8">
  </g>

  <g appOperator transform="translate(295, 45)"></g>

  <text x="337" y="110" fill="white" text-anchor="middle" font-size="0.8em">{{getCounterValue()}}s</text>

  <g transform="translate(496, 20)" appSubscriber [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)">
  </g>

  <g>
    <text x="300" y="136">{{elementInStandBy}}</text>
    <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x" y="136">{{element.value}}</text>
  </g>
</svg>