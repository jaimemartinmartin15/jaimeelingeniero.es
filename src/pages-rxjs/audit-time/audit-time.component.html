<div class="page-header">
    <h1 class="title">AuditTime</h1>
    <a class="link-rxjs" href="https://rxjs.dev/api/operators/auditTime" target="_blank">rxjs auditTime â¡ï¸</a>
</div>

<p>
    Este operador ignora los elementos del Observable fuente durante un tiempo determinado y luego emite el Ãºltimo que
    se haya emitido pasado ese tiempo. El contador para ignorar los elementos comienza cuando se detecta un elemento en
    el Observable fuente.
</p>

<textarea highlight-js [lang]="'typescript'">
import { auditTime, Observable } from 'rxjs';

new Observable((suscriptor) => {
  setTimeout(() => suscriptor.next('ğŸ'), 200);
  setTimeout(() => suscriptor.next('ğŸŒ'), 300);
  setTimeout(() => suscriptor.next('ğŸ“'), 1100);
  setTimeout(() => suscriptor.next('ğŸŠ'), 1200);
})
  .pipe(auditTime(500))
  .subscribe({
    next: (value) => console.log(`The next value is: ${value}`),
    error: (error) => console.error(`There is an error: ${error}`),
    complete: () => console.log('Completed'),
  });

// Output
// The next value is: ğŸŒ
// The next value is: ğŸŠ
</textarea>

<p>
    Expliquemos el ejemplo. Primero se emite una ğŸ a los 200 milisegundos. En este momento comienza el temporizador del
    operador. DespuÃ©s se emite el ğŸŒ pasados 100 milisegundos mÃ¡s. Y cuando llega el contador total a 700 milisegundos,
    el temporizador termina. Como el Ãºltimo elemento emitido es el ğŸŒ, se emite el ğŸŒ. Ahora el tiempo simplemente pasa,
    hasta que se emite la ğŸ“. Entonces el contador se vuelve a iniciar. Se emite tambiÃ©n la ğŸŠ. Y cuando el temporizador
    llega a cero en los 1600 milisegundos, se emite la ğŸŠ, porque fuÃ© lo Ãºltimo que se emitiÃ³.
</p>

<p>PruÃ©balo en esta demo:</p>