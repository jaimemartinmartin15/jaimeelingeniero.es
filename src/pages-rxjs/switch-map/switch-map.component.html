<div class="page-header">
  <h1 class="title">SwitchMap</h1>
  <a class="link-rxjs" href="https://rxjs.dev/api/operators/switchMap" target="_blank">rxjs switchMap 俱뫮잺</a>
</div>

<p>
  Este operador coge cada uno de los elementos emitidos por un Observable fuente y devuelve un nuevo Observable por
  cada elemento, cuyos elementos emitidos ser치n puestos de nuevo en el observable fuente y que ser치n los que se entregen
  al subscriptor. En el momento en el que un nuevo elemento es emitido en el Observable fuente, se cancela el Observable
  creado del elemento anterior y se suscribe al nuevo.
</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable, switchMap } from 'rxjs';

// This is the source observable
const numbers$ = new Observable<number>((observer) => {
  observer.next(1);
  observer.next(2);
  observer.next(0);
  observer.next(3);
});

// Use the pipe method to add operators
numbers$
  .pipe(
    switchMap(
      (number) =>
        new Observable((observer) => {
          if (number === 0) {
            setTimeout(() => {
              observer.error('No existences');
            }, 1000);
          } else if (number == 1) {
            setTimeout(() => {
              observer.next('游꼝'.repeat(number));
              observer.complete();
            }, 1000);
          } else {
            observer.next('游꼝'.repeat(number));
            observer.complete();
          }
        })
    )
  )
  .subscribe(
    (value) => console.log(`The next value is: ${value}`),
    (error) => console.error(`There is an error: ${error}`)
  );

// Output
// ======
// The next value is: 游꼝游꼝
// The next value is: 游꼝游꼝游꼝
</textarea>

<p>
  En este ejemplo tenemos un Observable que emite n칰meros, y por cada n칰mero tenemos otro observable que nos emite
  tantas manzanas como diga ese n칰mero. En el momento que hay un error en cualquiera de los Observables este se emite al
  subscriptor y todos los Observables pendientes se cancelan.
</p>

<p>
  Primero se emite el elemento n칰mero 1. Este elemento crea un Observable que emitir치 una manzana pasado un segundo. A
  continuaci칩n se emite el elemento n칰mero 2. Esto provoca que el Observable que emit칤a una manzana se cancele y hace
  que se emitan las dos manzanas inmediatamente. El Observable del n칰mero 2 completa y se emite el n칰mero 0, que emitir치
  un error al cabo de un segundo. Pero entonces se emite el n칰mero 3, que cancela el Observable que emite el error y se
  emiten las tres manzanas.
</p>

<p>
  A continuaci칩n te dejo un simulador para que pruebes:
</p>

<svg appDemoContainer viewBox="0 0 850 640">
  <g appConveyorController transform="translate(50,490)" [button1]="controllerButtons[MAIN_O][0]"
    [button2]="controllerButtons[MAIN_O][1]" [button3]="controllerButtons[MAIN_O][2]"
    [button4]="controllerButtons[MAIN_O][3]" [button5]="controllerButtons[MAIN_O][4]"
    (onButtonClick)="onControllerButtonClick($event)">
  </g>

  <g transform="translate(260, 490)" appConveyorHorizontal [length]="403" [conveyorWorking$]="conveyorsWorking[MAIN_O]">
  </g>

  <g appSubscriber transform="translate(690,420)" [showSpeechBubble$]="speechBubble$"
    (onSubscribe$)="onSubscribe($event)"></g>

  <g appOperator transform="translate(420, 452)"></g>

  <g [attr.transform]="'translate('+(460 - (200*(SWITCH.length/2)))+', 70)'">
    <g [attr.transform]="'translate('+200*i+',0)'" *ngFor="let S_ID of SWITCH; let i = index;" @animationConveyor>
      <g appConveyorController [attr.transform]="'translate(25,0)'" [button1]="controllerButtons[S_ID][0]"
        [button2]="controllerButtons[S_ID][1]" [button3]="controllerButtons[S_ID][2]"
        [button4]="controllerButtons[S_ID][3]" [button5]="controllerButtons[S_ID][4]"
        (onButtonClick)="onControllerButtonClick($event)">
      </g>

      <g [attr.transform]="'translate(70, 120)'" appConveyorVertical [length]="203"
        [conveyorWorking$]="conveyorsWorking[S_ID]">
      </g>
    </g>
  </g>

  <g>
    <text *ngFor="let element of elementsInConveyor" [attr.x]="element.x" [attr.y]="element.y">{{element.value}}</text>
  </g>
</svg>