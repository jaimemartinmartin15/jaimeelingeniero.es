<div class="page-header">
    <h1>Observable</h1>
    <a class="link-rxjs" href="https://rxjs.dev/guide/observable" target="_blank">rxjs observable â¡ï¸</a>
</div>

<p>
    Â¿QuÃ© es un Observable? Voy a explicarte quÃ© es un Observable con manzanas ğŸ.
</p>

<p>
    ImagÃ­nate que un Observable es una cinta transportadora que emite manzanas (datos). TÃº te pones al final llamando al
    mÃ©todo subscribe y le pasas una callback (<span class="next">next</span>), una callback
    (<span class="error">error</span>) y una callback (<span class="complete">complete</span>) que se invocan
    cuando la manzana llega al final (<span class="next">next</span>), cuando viene otra cosa que no es una manzana
    (<span class="error">error</span>), o cuando la cinta se para (<span class="complete">complete</span>).
</p>

<p>
    Entre medias (el pipe) estan los operadores que pueden manipular esas manzanas, pero los veremos en otras secciones.
</p>

<p>Veamos un primer ejemplo, uno sencillo:</p>

<textarea highlight-js [lang]="'typescript'">
import { Observable } from 'rxjs';

const myFirstObservable = new Observable(observer => {
    doSomeStuff();
    observer.next('ğŸ'); // will invoke next callback passed in the subscribe method
    doOtherSuff();
    observer.next('ğŸ');
    observer.complete(); // will invoke complete callback passed in the subscribe method
});

// the callback functions passed to the observable are not executed until we subscribe
myFirstObservable.subscribe(
    value => console.log(`The next value is: ${value}`),
    error => console.log(`Error: ${error}`),
    () => console.log('The observable has completed')
)

// Output
// ======
// The next value is: ğŸ
// The next value is: ğŸ
// The observable has completed
</textarea>

<p>
    Cuando creamos un objeto de tipo Observable con la palabra reservada new, le tenemos que
    pasar una funcion que toma un parÃ¡metro: el observador.
</p>

<p>
    Lo bueno de esta funciÃ³n es que puede "devolver" varios resultados llamando al mÃ©todo <span class="next">next</span>
    del observador.
    Cuando ha devuelto todos los valores el Observable se completa y ya no volverÃ¡ a emitir mÃ¡s valores. Igual si
    el observable emite un error, ya no se devuelven mÃ¡s valores:
</p>

<textarea highlight-js [lang]="'typescript'">
new Observable((subscriber) => {
    setTimeout(() => observer.next('This is timeout ğŸŠ'), 10); // it won't emit
    observer.next('ğŸ');
    observer.next('ğŸ');
    observer.error('ğŸš—')
    console.log('This code still is executed: ğŸ“');
    observer.next('ğŸ'); // it won't emit
})
.subscribe(
    fruit => console.log(`Next: ${fruit}`),
    error => console.log(`Error: ${fruit}`),
    () => console.log('Observable completed'),
);

// Output
// ======
// Next: ğŸ
// Next: ğŸ
// Error: ğŸš—
// This code still is executed: ğŸ“
</textarea>

<p>
    Aunque por mÃ¡s que llamemos a mÃ¡s mÃ©todos del observador (next, error o complete) este no emitirÃ¡ eventos y las
    funciones callback del subscribe no se ejecutarÃ¡n, porque el Observable ha completado o emitido un error.
</p>

<p>
    A continuaciÃ³n te dejo un simulador para que pruebes:
</p>

<div class="demo">
    <app-conveyor-controller class="conveyor-controller" (onClickNext)="onClickNext()" (onClickError)="onClickError()"
        (onClickComplete)="onClickComplete()">
        <ng-container ngProjectAs="[next]">ğŸ</ng-container>
        <ng-container ngProjectAs="[error]">ğŸŒ</ng-container>
        <ng-container ngProjectAs="[complete]">ğŸ–ï¸</ng-container>
    </app-conveyor-controller>

    <app-conveyor class="conveyor" [conveyorWorking$]="conveyorWorking$" [addToConveyor$]="addToConveyor$"
        (elementDelivered)="onEventDelivered($event)">
    </app-conveyor>

    <app-subscriber class="subscriber" [speechBubble$]="speechBubble$" (onSubscribe$)="onSubscribe($event)">
    </app-subscriber>
</div>