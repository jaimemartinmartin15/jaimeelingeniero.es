

<app-header-print [data]="headerPrintData"></app-header-print>

<main>
  <h1 class="title">SQL</h1>

  <section>
    <h2>Introducci칩n</h2>

    <p>
      Para empezar, SQL son las siglas de <strong>Structured Query Language</strong>, que en espa침ol significa
      <i>Lenguaje de consultas estructurado</i>. Es un lenguaje y sirve para realizar consultas a bases de datos
      relacionales. Resumi칠ndolo mucho una base de datos relacional son varias tablas relacionadas entre s칤, con sus
      filas y sus columnas.
    </p>

    <p>
      Este lenguaje es un est치ndar, por lo que pueden existir diferentes implementaciones o tambi칠n llamados dialectos
      que pueden diferir entre s칤 con elementos que no est치n en el est치ndar. Ejemplos son las implementaciones de
      Oracle, Microsoft, MySQL o PostgreSQL.
    </p>

    <p>
      Como todo lenguaje tiene su sintaxis y sus palabras reservadas, y es lo que vamos a ver a continuaci칩n. Vamos
      derecho a ello.
    </p>
  </section>

  <section>
    <h2>Entorno</h2>

    <p>
      Para poder practicar necesitamos tener alg칰n programa instalado que nos permita crear bases de datos y realizar
      consultas. En mi caso voy a usar MySql, que es un sistema de gesti칩n de bases de datos relacional con licencia
      dual, es decir, tiene una parte libre y otra comercial. Si tienes curiosidad investiga lo que significa, yo
      tampoco lo sab칤a.
    </p>

    <p>
      Como sistema operativo usar칠 Ubuntu. Es muy sencillo de instalar, as칤 que por aqu칤 dejo los comandos. Por cierto,
      lo he hecho como usuario root.
    </p>

    <app-terminal-code>
      <p terminal-code-command>apt-get update</p>
      <p terminal-code-command>apt-get install mysql-server</p>
      <p terminal-code-command>mysql --version</p>
      <p terminal-code-output>mysql Ver 8.0.32-0ubuntu0.20.04.2 for Linux on x86_64 ((Ubuntu))</p>
    </app-terminal-code>

    <p>Estando instalado, para conectarnos con una terminal donde aprender sql tenemos este comando:</p>

    <app-terminal-code>
      <p terminal-code-command>
        mysql -h &lt;dominio-o-direccionIP&gt; -u &lt;usuario&gt; -p&lt;password&gt;
        &lt;nombreBaseDeDatos&gt;
      </p>
    </app-terminal-code>

    <p>
      En mi caso el dominio es localhost, as칤 que lo omito. F칤jate que la contrase침a tiene que ir pegada al par치metro
      -p. Si pones un espacio no te la tomar치 y te pedir치 la contrase침a al pulsar intro. El nombre de la base de datos
      tambi칠n es opcional. Como a칰n no tenemos ninguna, no lo pongo.
    </p>

    <app-terminal-code>
      <p terminal-code-command>mysql -u root -p</p>
      <p terminal-code-output>Enter password:</p>
      <p terminal-code-output>mysql></p>
    </app-terminal-code>
  </section>

  <section>
    <h2>Crear una base de datos</h2>

    <p>
      Para empezar a trabajar lo primero que tenemos que tener o crear es la base de datos. En este art칤culo vamos a
      crear una base de datos para un negocio fiction de coches. Esto es sencillo de hacer:
    </p>

    <app-terminal-code>
      <p terminal-code-command>create database automoviles;</p>
      <p terminal-code-output>Query OK, 1 row affected (0,00 sec)</p>
    </app-terminal-code>

    <p>
      Ya esta creada la base de datos. La he llamado <i>automoviles</i>. Lo 칰nico que no tiene tablas ni informaci칩n.
      Podemos ver las bases de datos que tenemos con:
    </p>

    <app-terminal-code>
      <p terminal-code-command>show databases;</p>
      <pre terminal-code-output>+--------------------+
| Database           |
+--------------------+
| automoviles        |
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      Vemos que nuestra base de datos est치 ah칤. Las otras son cosas del servidor y contienen metainformaci칩n. Mejor no
      tocarlas.
    </p>

    <p>
      Para trabajar con la base de datos creada, la debemos seleccionar. De esta forma los comandos que escribamos ir치n
      por defecto dirigidos a ella.
    </p>

    <app-terminal-code>
      <p terminal-code-command>use automoviles;</p>
      <p terminal-code-output>Database changed</p>
    </app-terminal-code>
  </section>

  <section>
    <h2>Crear tablas</h2>

    <p>
      Una base de datos sin informaci칩n no vale para nada. Y la informaci칩n se guarda en tablas. As칤 que vamos a ver
      como crearlas.
    </p>

    <code>
      <pre class="command-sintax">CREATE TABLE nombreTabla (
  nombreColumna 
    tipo
    [NOT NULL]
    [DEFAULT valorPorDefecto]
    [[CONSTRAINT nombreConstraint] UNIQUE]
    [[CONSTRAINT nombreConstraint] PRIMARY KEY]
    [[CONSTRAINT nombreConstraint] REFERENCES tabla (columna) [ON DELETE opcionAccion] [ON UPDATE opcionAccion]]
    [[CONSTRAINT nombreConstraint] CHECK (expresi칩nBooleana)],
  [[CONSTRAINT nombreConstraint] UNIQUE (columna, columna, ...)],
  [[CONSTRAINT nombreConstraint] PRIMARY KEY (columna, columna, ...)],
  [[CONSTRAINT nombreConstraint] FOREIGN KEY (columna, columna, ...) REFERENCES
    tabla (columna, columna, ...) [ON DELETE opcionAccion] [ON UPDATE opcionAccion]],
  [[CONSTRAINT nombreConstraint] CHECK (expresi칩nBooleana)]
);</pre>
    </code>

    <p>
      Esta sentencia crear치 una tabla en la base de datos seleccionada. El propietario de la tabla ser치 el usuario que
      la crea, es decir, el usuario que usaste para loguearte en el Sitema Gestor de Bases de Datos (SGBD).
    </p>

    <p>
      Lo que tenemos son dos secciones: definici칩n de columnas de la tabla, y definici칩n de reglas de integridad para la
      tabla entera. Cada columna o restricci칩n de tabla va separada por una coma.
    </p>

    <p>
      Lo imprescindible para definir una columna es el nombre y su tipo. El nombre lo eliges t칰 y el tipo puede
      depender del SGBD. Estos son algunos de los habituales: VARCHAR, DATE, INTEGER, DECIMAL. Consulta el manual del
      SGBD para m치s informaci칩n.
    </p>

    <p>
      Adem치s del nombre y el tipo podemos opcionalmente poner restricciones, como si la columna puede tener valores
      vac칤os o ponerle valores por defecto si no los indicamos al meter datos.
    </p>

    <p>
      Toda tabla tiene una PRIMARY KEY, que quiere decir que los valores de esa columna no se repiten para ninguna fila.
      Con UNIQUE podemos decirle lo mismo, pero sin que sea la PRIMARY KEY oficial. Con CONSTRAINT podemos poner nombres
      a estas restricciones para luego poder editarlas en caso de necesitarlo.
    </p>

    <p>
      Con REFERENCES podemos decir que el valor de la columna tendr치 que ser un valor que coincida con alguno de otra
      columna en una fila de otra tabla, o de no ser as칤, el valor ser칤a NULL. De esta forma indicamos una FOREIGN KEY.
      Las opciones para ON DELETE y ON UPDATE pueden ser:
    </p>

    <ul>
      <li>
        CASCADE: eliminar치 o actualizar치 las filas de la tabla actual (la que estamos creando) si eliminamos o
        actualizamos el valor referenciado en la tabla referenciada.
      </li>
      <li>
        SET NULL: establece el valor de la columna a NULL cuando eliminamos o actualizamos el valor referenciado en la
        tabla referenciada.
      </li>
      <li>
        SET DEFAULT: se establece el valor por defecto definido para la columna cuando se elimina o modifica el valor
        referenciado en la tabla referenciada.
      </li>
      <li>
        RESTRICT: evita eliminar o actualizar la fila en la tabla referenciada si tenemos valores que hacen referencia a
        ella en la tabla actual.
      </li>
      <li>
        NO ACTION: indica que no hay ninguna acci칩n definida y que depende del sistema gestor de base de datos como
        gestionarlo. En el caso de MySql, es lo mismo que RESTRICT.
      </li>
    </ul>

    <p>
      Si no ponemos la opci칩n ON DELETE u ON UPDATE nos dejar치 eliminar o actualizar cualquier fila en la tabla
      referenciada pero la base de datos podr칤a quedar incosistente.
    </p>

    <p>
      Por 칰ltimo con CHECK podemos hacer validaciones sobre el valor. Por ejemplo, si es una edad lo que vamos a guardar
      en la columna podemos comprobar que sea mayor que cero antes de introducir datos en la tabla.
    </p>

    <p>
      La segunda secci칩n ser칤an las restricciones de la tabla. En caso que queramos poner restricciones que impliquen a
      varias columnas podemos decirlo aqu칤.
    </p>

    <p>
      Ahora que conocemos la sintaxis vamos a crear las tablas de nuestra base de datos. Este ser치 el esquema:
    </p>

    <img class="bbdd-scheme-image" src="pages-bbdd/assets/bbdd-scheme.png" alt="Esquema base de datos">

    <p>
      Despliega los elementos para ver la orden que crea las tablas:
    </p>

    <div class="collapsible">
      <p class="collapsible__title"
        (click)="collapsedTables.createTableMechanic = !collapsedTables.createTableMechanic">
        MECANICO
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableMechanic}">
        <pre terminal-code-command>CREATE TABLE MECANICO (
  codigo INT not null primary key,
  nombre VARCHAR(50) not null,
  ciudad VARCHAR(50) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title"
        (click)="collapsedTables.createTablePropulsion = !collapsedTables.createTablePropulsion">
        PROPULSION
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTablePropulsion}">
        <pre terminal-code-command>CREATE TABLE PROPULSION (
  id INT not null primary key,
  nombre VARCHAR(30) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableBrand = !collapsedTables.createTableBrand">
        MARCA
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableBrand}">
        <pre terminal-code-command>CREATE TABLE MARCA (
  codigo INT not null primary key,
  nombre VARCHAR(20) not null,
  sede VARCHAR(20) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,01 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title"
        (click)="collapsedTables.createTableConcessionaire = !collapsedTables.createTableConcessionaire">
        CONCESIONARIO
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableConcessionaire}">
        <pre terminal-code-command>CREATE TABLE CONCESIONARIO (
  codigo INT not null primary key, 
  localidad VARCHAR(50) not null,
  hora_apertura TIME not null,
  hora_cierre TIME not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,03 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableClient = !collapsedTables.createTableClient">
        CLIENTE
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableClient}">
        <pre terminal-code-command>CREATE TABLE CLIENTE (
  dni VARCHAR(15) not null primary key,
  nombre VARCHAR(40) not null,
  fecha_nac DATE not null,
  telefono VARCHAR(15) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,01 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableCar = !collapsedTables.createTableCar">
        COCHE
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableCar}">
        <pre terminal-code-command>CREATE TABLE COCHE (
  codigo INT not null primary key,
  cod_marca INT not null references MARCA(codigo) ON DELETE RESTRICT,
  modelo VARCHAR(60) not null,
  propulsion INT not null references PROPULSION(id) ON DELETE RESTRICT
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableOffer = !collapsedTables.createTableOffer">
        OFRECE
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableOffer}">
        <pre terminal-code-command>CREATE TABLE OFRECE (
  cod_coche INT not null references COCHE(codigo) ON DELETE RESTRICT,
  cod_concesionario INT not null references CONCESIONARIO(codigo) ON DELETE RESTRICT,
  cantidad INT check(cantidad > 0),
  primary key (cod_coche, cod_concesionario)
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableRepair = !collapsedTables.createTableRepair">
        REPARA
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableRepair}">
        <pre terminal-code-command>CREATE TABLE REPARA (
  id INT not null primary key,
  cod_mecanico INT not null references MECANICO(codigo) ON DELETE RESTRICT, 
  cod_coche INT not null references COCHE(codigo) ON DELETE RESTRICT,
  fecha INT not null,
  precio DECIMAL(10,2) not null check(precio > 0)
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,01 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableSale = !collapsedTables.createTableSale">
        VENTA
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableSale}">
        <pre terminal-code-command>CREATE TABLE VENTA (
  num_factura VARCHAR(15) not null primary key,
  cod_cliente VARCHAR(15) not null references CLIENTE(dni) ON DELETE RESTRICT,
  cod_coche INT not null,
  cod_concesionario INT not null,
  precio DECIMAL(10,2) not null check(precio > 100),
  fecha VARCHAR(30) not null,
  foreign key (cod_coche, cod_concesionario) references OFRECE(cod_coche, cod_concesionario)
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <!-- TODO put link with scripts to create tables. 쯜n a zip file? -->
  </section>

  <section>
    <h2>Alteraci칩n de tablas</h2>

    <p>
      A medida que vamos usando la base de datos y los requisitos de nuestra aplicaci칩n varian, puede que tengamos que
      cambiar restricciones, referencias, eliminar o a침adir nuevas columnas, etc. Y eso es lo que vamos a ver antes de
      rellenar la base de datos por si te equivocaste al crear una de las tablas.
    </p>

    <p>
      Veamos como eliminar una tabla. Ten en cuenta que s칩lo se podr치 eliminar si no est치 referenciada por ninguna otra
      tabla u objeto en la base de datos (en caso de haber puesto las restricciones oportunas).
    </p>

    <code>
      <pre class="command-sintax">DROP TABLE nombre_de_la_tabla</pre>
    </code>

    <p>
      Ahora veamos como a침adir o eliminar una columna de una tabla, o sus restricciones:
    </p>

    <code>
      <pre class="command-sintax">ALTER TABLE nombreTabla
  ADD [COLUMN] especificaci칩nColumna,
  DROP [COLUMN] nombreColumna,
  ALTER [COLUMN] redefinici칩nColumna,
  ADD CONSTRAINT nombreConstraint restriccionDeTabla,
  DROP CONSTRAINT nombreConstraint;</pre>
    </code>

    <p>



      <!-- TODO revisar este comentario. Si lo separamos por coma se puede hacer a la vez? -->



      Estas sentencias hay que ejecutarlas de una en una. No se puede a침adir una columna a la vez que se elimina otra,
      por ejemplo. Para a침adir una columna nueva la especificaci칩n de la columna es como cuando creamos una tabla. Y
      para eliminarla, simplemente indicamos el nombre. Si queremos redefinir la columna, es lo mismo, es como si
      estuvieramos defini칠ndola desde cero. Y con las restricciones de clave primaria, o for치nea o un check es m치s de lo
      mismo, igual que si lo estuvieramos definiciendo como cuando creamos una tabla.
    </p>

    <p>
      Ahora veamos un ejemplo para cambiar el tipo de una columna.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>ALTER TABLE REPARA MODIFY fecha DATE default (CURRENT_DATE);</pre>

      <pre terminal-code-output>Query OK, 0 rows affected (0,03 sec)
Records: 0  Duplicates: 0  Warnings: 0</pre>
    </app-terminal-code>

    <p>
      En test caso, puesto que estamos modificando una columna existente y cambiando su tipo, usamos la palabra MODIFY.
      Despu칠s la sintaxis es la misma que ya hemos visto para definir una columna. Hay que tener en cuenta que al
      cambiar el tipo de dato podemos perder los valores de la columna si no son compatibles con el nuevo tipo. Tambi칠n
      puede que tengamos que eliminar primero ciertas restricciones antes de operar sobre la columna.
    </p>
  </section>

  <section>
    <h2>Rellenando la base de datos</h2>

    <p>
      Ahora s칤 ha llegado la hora de meter informaci칩n en nuestra base de datos. Veamos la orden en general:
    </p>

    <code>
      <pre class="command-sintax">INSERT INTO tabla [(lista, de, columnas)] VALUES (lista, de, valores);</pre>
    </code>

    <p>
      La orden es muy sencillita. Especificamos las columnas que vamos a rellenar y sus valores. Entonces se crear치 una
      nueva fila en la tabla. Vamos a introducir algunas filas.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>INSERT INTO MARCA VALUES(1, 'Toyota', 'Jap칩n');</pre>
      <pre terminal-code-output>Query OK, 1 row affected (0,01 sec)</pre>
    </app-terminal-code>

    <p>
      En este caso no he necesitado proporcionar el nombre de las columnas porque he proporcionado todos los valores en
      el orden que especificamos las columnas.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>INSERT INTO COCHE VALUES(18, 2, 'Model', 1);</pre>
      <pre
        terminal-code-output>ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`business`.`COCHE`, CONSTRAINT `COCHE_ibfk_1` FOREIGN KEY (`cod_marca`) REFERENCES `MARCA` (`codigo`))</pre>
    </app-terminal-code>

    <p>
      En esta otra orden hemos intentado a침adir un coche haciendo referencia a una marca que no existe, y tal es el caso
      que el sistema ha rechazado la transacci칩n.
    </p>

    <p>
      Ahora para eliminar una fila de la tabla lo hacemos con esta otra orden:
    </p>

    <code>
      <pre class="command-sintax">DELETE FROM tabla WHERE condicion</pre>
    </code>

    <p>
      Es muy importante especificar la condici칩n con la palabra WHERE. De otra forma <strong>se eliminar칤an todas las
        filas de la tabla.</strong>
    </p>
  </section>

  <section>
    <h2>La sentencia SELECT</h2>

    <p>
      Esta es la sentencia b치sica para recuperar datos de una base de datos. El formato de una consulta con esta
      sentencia es:
    </p>

    <code>
      <pre class="command-sintax">SELECT [ALL | DISTINCT]
expresi칩n
FROM tabla
WHERE condici칩n
GROUP BY columna 
HAVING condici칩n 
ORDER BY columna/n췈 columna [ASC | DESC]</pre>
    </code>

    <p>
      La salida del comando es otra tabla con tantas filas como filas de la tabla a consultar cumplan la condici칩n y
      tantas columnas como expresiones indiquemos.
    </p>

    <p>
      Con la orden SELECT indicamos que vamos a seleccionar datos de la tabla. La opci칩n ALL es por defecto y significa
      que seleccione todas las filas aunque est칠n repetidas. Si ponemos DISTINCT la tabla de salida solo tendr치 filas
      que no est치n repetidas (se eliminan las que est치n duplicadas).
    </p>

    <p>
      La segunda l칤nea es una expresi칩n. Podemos poner varias separadas por comas. Consiste en el nombre de una columna
      de la tabla, o expresiones matem치ticas, o llamadas a funciones que manejen datos de tipo fecha o num칠rico o
      string. Podemos hacer que se concatenen columnas en una sola, y muchas m치s cosas.
    </p>

    <p>
      Con FROM indicamos la tabla de la cual vamos a seleccionar datos.
    </p>

    <p>
      Con WHERE podemos indicar las condiciones para seleccionar filas de la tabla. Podemos usar operadores l칩gicos
      (AND, OR y NOT), de comparaci칩n (=, &lt;&gt;, &lt;, &lt;=, &gt;,&gt;=) o predicados m치s avanzados (IN, BETWEEN,
      LIKE, IS NULL)
    </p>

    <p>
      Con GROUP BY podemos agrupar las filas resultantes en funci칩n de una de las columnas. Permite realizar operaciones
      de agregaci칩n, como sumas o promedios, por ejemplo. La tabla resultante tras usar esta cl치usula, tiene una fila
      por cada grupo formado, es decir, por cada valor de la columnas o columnas. En el SELECT solo podremos tener
      columnas usadas en el GROUP BY y funciones.
    </p>

    <p>
      Con HAVING podemos filtrar los grupos con la condici칩n indicada. Es igual que el WHERE, pero filtra grupos en vez
      de filas. La condici칩n del WHERE se aplica a filas antes de agrupar, y el HAVING se aplica a grupos despu칠s de
      agrupar.
    </p>

    <p>
      Con ORDER BY podemos ordenar las filas de la tabla resultante de forma ascendente o descendente. Podemos hacerlo
      indicando el 칤ndice de una columna o su nombre. El nombre de la columna es el de la tabla original, o si es una
      columna compuesta (una expresi칩n m치s compleja) podemos poner AS en la expresi칩n para ponerle un nombre a la
      columna resultante.
    </p>
  </section>

  <section>
    <h2>Ejemplo b치sico de consulta</h2>

    <p>
      Para poner en pr치ctica la sentencia SELECT voy a poner unos ejemplos de como usarla.
    </p>

    <p>
      Vamos a consultar todos los mec치nicos que hay en la tabla MECANICO:
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT * from MECANICO;</span>
      <pre terminal-code-output>+--------+---------------------------------------+------------------------+
| codigo | nombre                                | ciudad                 |
+--------+---------------------------------------+------------------------+
|      1 | Mec치nica H치bil T칠cnico                | Cuenca                 |
|      2 | Diagn칩stico H치bil Total               | Burgos                 |
|      3 | Servicio R치pido Automotriz            | Zamora                 |
|      4 | T칠cnica Experto de Coches             | Almer칤a                |
|      5 | Electromec치nica Eficiente Express     | Girona                 |
|      6 | Mantenimiento Fiable de Coches        | Teruel                 |
|      7 | T칠cnica Preciso del Motor             | Castell칩n de la Plana  |
|      8 | Mec치nica Innovador Mec치nico           | C치ceres                |
|      9 | Electromec치nica Innovador Automotriz  | Huelva                 |
|     10 | Neum치ticos Eficiente Mantenimiento    | Lugo                   |
+--------+---------------------------------------+------------------------+
10 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      Si como expresi칩n usamos el comod칤n (<strong>*</strong>) se seleccionan todas las columnas.
    </p>

    <p>
      Ahora vamos a seleccionar el nombre de las marcas que tienen sede en Alemania:
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT nombre FROM MARCA where sede="alemania" ORDER BY 1;</span>
      <pre terminal-code-output>+---------------+
| nombre        |
+---------------+
| Audi          |
| BMW           |
| Mercedes-Benz |
| Volkswagen    |
+---------------+
4 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      En esta otra sentencia la columna nos sale ordenada alfab칠ticamente al haber especificado el ORDER BY. Como s칩lo
      tenemos una columna en la salida, pues decimos que nos lo ordene por la primera columna, de ah칤 el 1.
    </p>

    <p>
      Ahora pidamos una consulta algo m치s compleja. Queremos saber la cantidad total de coches que ofrece cada
      concesionario.
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT cod_concesionario, sum(cantidad) as total_coches FROM OFRECE GROUP BY
        cod_concesionario ORDER BY 1;</span>
      <pre terminal-code-output>+-------------------+--------------+
| cod_concesionario | total_coches |
+-------------------+--------------+
|                 1 |         1629 |
|                 2 |         1515 |
|                 3 |         1002 |
|                 4 |         1594 |
|                 5 |         1302 |
|                 6 |         1397 |
|                 7 |         1335 |
|                 8 |         1664 |
|                 9 |          964 |
|                10 |         1193 |
|                11 |         1189 |
|                12 |         1283 |
|                13 |         1394 |
|                14 |         1317 |
|                15 |         1312 |
+-------------------+--------------+
15 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      Esta tabla tiene dos columnas. La primera es parte de la tabla original, y la segunda la hemos puesto un alias
      <i>total_coches</i>, que es la suma de todas las cantidades por concesionario.
    </p>

    <p>
      Calculemos ahora la media de coches que ofrecen los concesionarios:
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT floor(avg(total_coches)) as promedio FROM (SELECT cod_concesionario,
        sum(cantidad) as total_coches FROM OFRECE GROUP BY cod_concesionario ORDER BY 1) as T;</span>
      <pre terminal-code-output>+----------+
| promedio |
+----------+
|     1339 |
+----------+
1 row in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      En esta ocasi칩n hemos tenido que anidar dos sentencias y para ello he usado los par칠ntesis. Primero se obtiene la
      cantidad de coches de cada concesionario y sobre la tabla resultante, se calcula el promedio. Es obligatorio poner
      un alias a la tabla resultante anidada. En este caso simplemente la he llamado T.
    </p>
  </section>

  <section>
    <h2>El JOIN</h2>

    <p>
      Hasta ahora solo hemos hecho consultas que implicaban una tabla. 쯇ero que pasa si la informaci칩n est치 distribuida
      por varias de ellas? Para eso usaremos el JOIN.
    </p>

    <p>
      El JOIN nos permite combinar las tablas que aparezcan en la cl치usula FROM. La tabla resultante de la combinaci칩n
      es otra tabla resultado de aplicar el producto cartesiano de las tablas implicadas. Con esta im치gen entenderemos
      mejor que es el producto cartesiano:
    </p>

    <img class="combination-table-image" src="pages-bbdd/assets/combination_table.png" alt="Combinaci칩n de tablas">

    <p>
      La orden para combinar las tablas ser칤a as칤:
    </p>

    <code>
      <pre class="command-sintax">SELECT ta.c2, tb.c2, c5, ...
FROM tablaA ta, tablaB tb, tablaC
WHERE condici칩n;</pre>
    </code>

    <p>
      En caso de que dos tablas tengan columnas con el mismo nombre, se deben usar alias para eliminar ambig칲edades.
      En este ejemplo, ta y tb son alias para la tablaA y la tablaB. Los alias son opcionales en otras circunstancias.
    </p>

    <p>
      Es importante especificar una cl치usula WHERE, ya que si no tendremos filas que no tendr치n ning칰n sentido tras
      realizar el producto cartesiano, y obtendremos resultados que pueden ser incorrectos o confusos. El caso m치s
      habitual es igualar dos columnas entre dos tablas, aunque tambi칠n se pueden usar otros operadores distintos al de
      la igualdad. En caso de relacionar m치s de dos tablas, recuerda que tambi칠n se pueden usar condiciones AND y OR
      para relacionar las columnas de varias tablas mediante varias condiciones.
    </p>

    <p>
      Para poder separar las condiciones que combinan las tablas correctamente de las condiciones que queremos para
      seleccionar las filas de nuestra consulta, se puede usar la operaci칩n JOIN en el FROM, que da como resultado la
      tabla sobre la que se operar치.
    </p>

    <code>
      <pre class="command-sintax">SELECT expresiones
FROM tabla1 [alias1] [INNER | LEFT | RIGHT | FULL | CROSS] JOIN tabla2 [alias2] ON condici칩nDelJoin;
WHERE condici칩nDeLaConsulta</pre>
    </code>

    <p>
      Existen varios tipos de JOIN. Vamos a explicarlos suponiendo que la condici칩n es que C2 de la tabla A es igual a
      C2 de la tabla B.
    </p>

    <p>
      El <strong>INNER JOIN</strong> es el JOIN por defecto. Devuelve s칩lo las filas que cumplen la condici칩n.
    </p>

    <img class="inner-join-image" src="pages-bbdd/assets/inner-join.png" alt="Inner join de tablas">

    <p>
      El <strong>LEFT JOIN</strong> devuelve todas las filas de la tabla de la izquierda (tabla A) y las que coinciden
      con la tabla derecha (tabla B). Si no hay coincidencias, se establece el valor a NULL en la tabla resultante.
    </p>

    <img class="left-join-image" src="pages-bbdd/assets/left-join.png" alt="Left join de tablas">

    <p>
      El <strong>RIGHT JOIN</strong> es igual que el LEFT JOIN, pero con la tabla de la derecha.
    </p>

    <img class="right-join-image" src="pages-bbdd/assets/right-join.png" alt="Right join de tablas">

    <p>
      El <strong>FULL JOIN</strong> es una combinaci칩n del LEFT JOIN y el RIGHT JOIN.
    </p>

    <img class="full-join-image" src="pages-bbdd/assets/full-join.png" alt="Full join de tablas">

    <p>
      Por 칰ltimo, el CROSS JOIN ser칤a realizar el producto cartesiano, que es lo que hab칤amos visto al principio.
    </p>
  </section>

  <section>
    <h2>Otros operadores</h2>

    <p>
      El operador <strong>UNION</strong> permite unir dos tablas que tienen el mismo n칰mero de columnas y que adem치s sus
      tipos coinciden. Si apareciesen resultados duplicados en la tabla resultante son eliminados. En caso de no querer
      elimnarlos existe la versi칩n <strong>UNION ALL</strong>.
    </p>

    <p>
      El operador <strong>INTERSECT</strong> entre dos tablas devuelve las filas que est치n en ambas tablas. Igualmente
      el n칰mero de columnas y el tipo debe coincidir. Recuerda que podemos utilizar select para coger solo las columnas
      que necesitemos y generar una tabla nueva 游땔
    </p>

    <p>
      El operador <strong>MINUS</strong> devuelve las filas que existen en la primera tabla pero no en la segunda.
    </p>

    <p>
      Por ejemplo, queremos saber que mec치nicos han reparado coches de la marca Tesla <strong>y</strong> Seat.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>select me.nombre from MECANICO me, REPARA r, COCHE c, MARCA ma where me.codigo=r.cod_mecanico AND r.cod_coche=c.codigo AND c.cod_marca=ma.codigo AND ma.nombre="Tesla"
intersect
select me.nombre from MECANICO me, REPARA r, COCHE c, MARCA ma where me.codigo=r.cod_mecanico AND r.cod_coche=c.codigo AND c.cod_marca=ma.codigo AND ma.nombre="Seat";</pre>
      
      <pre terminal-code-output>+-------------------------------+
| nombre                        |
+-------------------------------+
| T칠cnica Experto de Coches     |
| Mec치nica Innovador Mec치nico   |
+-------------------------------+
2 rows in set (0,01 sec)</pre>
    </app-terminal-code>
  </section>
</main>