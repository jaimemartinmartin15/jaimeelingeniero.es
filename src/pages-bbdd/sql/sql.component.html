

<app-header-print [data]="headerPrintData"></app-header-print>

<main>
  <h1 class="title">SQL</h1>

  <section>
    <h2>Introducción</h2>

    <p>
      Para empezar, SQL son las siglas de <strong>Structured Query Language</strong>, que en español significa
      <i>Lenguaje de consultas estructurado</i>. Es un lenguaje y sirve para realizar consultas a bases de datos
      relacionales. Resumiéndolo mucho una base de datos relacional son varias tablas relacionadas entre sí, con sus
      filas y sus columnas.
    </p>

    <p>
      Este lenguaje es un estándar, por lo que pueden existir diferentes implementaciones o también llamados dialectos
      que pueden diferir entre sí con elementos que no están en el estándar. Ejemplos son las implementaciones de
      Oracle, Microsoft, MySQL o PostgreSQL.
    </p>

    <p>
      Como todo lenguaje tiene su sintaxis y sus palabras reservadas, y es lo que vamos a ver a continuación. Vamos
      derecho a ello.
    </p>
  </section>

  <section>
    <h2>Entorno</h2>

    <p>
      Para poder practicar necesitamos tener algún programa instalado que nos permita crear bases de datos y realizar
      consultas. En mi caso voy a usar MySql, que es un sistema de gestión de bases de datos relacional con licencia
      dual, es decir, tiene una parte libre y otra comercial. Si tienes curiosidad investiga lo que significa, yo
      tampoco lo sabía.
    </p>

    <p>
      Como sistema operativo usaré Ubuntu. Es muy sencillo de instalar, así que por aquí dejo los comandos. Por cierto,
      lo he hecho como usuario root.
    </p>

    <app-terminal-code>
      <p terminal-code-command>apt-get update</p>
      <p terminal-code-command>apt-get install mysql-server</p>
      <p terminal-code-command>mysql --version</p>
      <p terminal-code-output>mysql Ver 8.0.32-0ubuntu0.20.04.2 for Linux on x86_64 ((Ubuntu))</p>
    </app-terminal-code>

    <p>Estando instalado, para conectarnos con una terminal donde aprender sql tenemos este comando:</p>

    <app-terminal-code>
      <p terminal-code-command>
        mysql -h &lt;dominio-o-direccionIP&gt; -u &lt;usuario&gt; -p&lt;password&gt;
        &lt;nombreBaseDeDatos&gt;
      </p>
    </app-terminal-code>

    <p>
      En mi caso el dominio es localhost, así que lo omito. Fíjate que la contraseña tiene que ir pegada al parámetro
      -p. Si pones un espacio no te la tomará y te pedirá la contraseña al pulsar intro. El nombre de la base de datos
      también es opcional. Como aún no tenemos ninguna, no lo pongo.
    </p>

    <app-terminal-code>
      <p terminal-code-command>mysql -u root -p</p>
      <p terminal-code-output>Enter password:</p>
      <p terminal-code-output>mysql></p>
    </app-terminal-code>
  </section>

  <section>
    <h2>Crear una base de datos</h2>

    <p>
      Para empezar a trabajar lo primero que tenemos que tener o crear es la base de datos. En este artículo vamos a
      crear una base de datos para un negocio fiction de coches. Esto es sencillo de hacer:
    </p>

    <app-terminal-code>
      <p terminal-code-command>create database automoviles;</p>
      <p terminal-code-output>Query OK, 1 row affected (0,00 sec)</p>
    </app-terminal-code>

    <p>
      Ya esta creada la base de datos. La he llamado <i>automoviles</i>. Lo único que no tiene tablas ni información.
      Podemos ver las bases de datos que tenemos con:
    </p>

    <app-terminal-code>
      <p terminal-code-command>show databases;</p>
      <pre terminal-code-output>+--------------------+
| Database           |
+--------------------+
| automoviles        |
| information_schema |
| mysql              |
| performance_schema |
| sys                |
+--------------------+
5 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      Vemos que nuestra base de datos está ahí. Las otras son cosas del servidor y contienen metainformación. Mejor no
      tocarlas.
    </p>

    <p>
      Para trabajar con la base de datos creada, la debemos seleccionar. De esta forma los comandos que escribamos irán
      por defecto dirigidos a ella.
    </p>

    <app-terminal-code>
      <p terminal-code-command>use automoviles;</p>
      <p terminal-code-output>Database changed</p>
    </app-terminal-code>
  </section>

  <section>
    <h2>Crear tablas</h2>

    <p>
      Una base de datos sin información no vale para nada. Y la información se guarda en tablas. Así que vamos a ver
      como crearlas.
    </p>

    <code>
      <pre class="command-sintax">CREATE TABLE nombreTabla (
  nombreColumna 
    tipo
    [NOT NULL]
    [DEFAULT valorPorDefecto]
    [[CONSTRAINT nombreConstraint] UNIQUE]
    [[CONSTRAINT nombreConstraint] PRIMARY KEY]
    [[CONSTRAINT nombreConstraint] REFERENCES tabla (columna) [ON DELETE opcionAccion] [ON UPDATE opcionAccion]]
    [[CONSTRAINT nombreConstraint] CHECK (expresiónBooleana)],
  [[CONSTRAINT nombreConstraint] UNIQUE (columna, columna, ...)],
  [[CONSTRAINT nombreConstraint] PRIMARY KEY (columna, columna, ...)],
  [[CONSTRAINT nombreConstraint] FOREIGN KEY (columna, columna, ...) REFERENCES
    tabla (columna, columna, ...) [ON DELETE opcionAccion] [ON UPDATE opcionAccion]],
  [[CONSTRAINT nombreConstraint] CHECK (expresiónBooleana)]
);</pre>
    </code>

    <p>
      Esta sentencia creará una tabla en la base de datos seleccionada. El propietario de la tabla será el usuario que
      la crea, es decir, el usuario que usaste para loguearte en el Sitema Gestor de Bases de Datos (SGBD).
    </p>

    <p>
      Lo que tenemos son dos secciones: definición de columnas de la tabla, y definición de reglas de integridad para la
      tabla entera. Cada columna o restricción de tabla va separada por una coma.
    </p>

    <p>
      Lo imprescindible para definir una columna es el nombre y su tipo. El nombre lo eliges tú y el tipo puede
      depender del SGBD. Estos son algunos de los habituales: VARCHAR, DATE, INTEGER, DECIMAL. Consulta el manual del
      SGBD para más información.
    </p>

    <p>
      Además del nombre y el tipo podemos opcionalmente poner restricciones, como si la columna puede tener valores
      vacíos o ponerle valores por defecto si no los indicamos al meter datos.
    </p>

    <p>
      Toda tabla tiene una PRIMARY KEY, que quiere decir que los valores de esa columna no se repiten para ninguna fila.
      Con UNIQUE podemos decirle lo mismo, pero sin que sea la PRIMARY KEY oficial. Con CONSTRAINT podemos poner nombres
      a estas restricciones para luego poder editarlas en caso de necesitarlo.
    </p>

    <p>
      Con REFERENCES podemos decir que el valor de la columna tendrá que ser un valor que coincida con alguno de otra
      columna en una fila de otra tabla, o de no ser así, el valor sería NULL. De esta forma indicamos una FOREIGN KEY.
      Las opciones para ON DELETE y ON UPDATE pueden ser:
    </p>

    <ul>
      <li>
        CASCADE: eliminará o actualizará las filas de la tabla actual (la que estamos creando) si eliminamos o
        actualizamos el valor referenciado en la tabla referenciada.
      </li>
      <li>
        SET NULL: establece el valor de la columna a NULL cuando eliminamos o actualizamos el valor referenciado en la
        tabla referenciada.
      </li>
      <li>
        SET DEFAULT: se establece el valor por defecto definido para la columna cuando se elimina o modifica el valor
        referenciado en la tabla referenciada.
      </li>
      <li>
        RESTRICT: evita eliminar o actualizar la fila en la tabla referenciada si tenemos valores que hacen referencia a
        ella en la tabla actual.
      </li>
      <li>
        NO ACTION: indica que no hay ninguna acción definida y que depende del sistema gestor de base de datos como
        gestionarlo. En el caso de MySql, es lo mismo que RESTRICT.
      </li>
    </ul>

    <p>
      Si no ponemos la opción ON DELETE u ON UPDATE nos dejará eliminar o actualizar cualquier fila en la tabla
      referenciada pero la base de datos podría quedar incosistente.
    </p>

    <p>
      Por último con CHECK podemos hacer validaciones sobre el valor. Por ejemplo, si es una edad lo que vamos a guardar
      en la columna podemos comprobar que sea mayor que cero antes de introducir datos en la tabla.
    </p>

    <p>
      La segunda sección serían las restricciones de la tabla. En caso que queramos poner restricciones que impliquen a
      varias columnas podemos decirlo aquí.
    </p>

    <p>
      Ahora que conocemos la sintaxis vamos a crear las tablas de nuestra base de datos. Este será el esquema:
    </p>

    <img class="bbdd-scheme-image" src="pages-bbdd/assets/bbdd-scheme.png" alt="Esquema base de datos">

    <p>
      Despliega los elementos para ver la orden que crea las tablas:
    </p>

    <div class="collapsible">
      <p class="collapsible__title"
        (click)="collapsedTables.createTableMechanic = !collapsedTables.createTableMechanic">
        MECANICO
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableMechanic}">
        <pre terminal-code-command>CREATE TABLE MECANICO (
  codigo INT not null primary key,
  nombre VARCHAR(50) not null,
  ciudad VARCHAR(50) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title"
        (click)="collapsedTables.createTablePropulsion = !collapsedTables.createTablePropulsion">
        PROPULSION
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTablePropulsion}">
        <pre terminal-code-command>CREATE TABLE PROPULSION (
  id INT not null primary key,
  nombre VARCHAR(30) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableBrand = !collapsedTables.createTableBrand">
        MARCA
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableBrand}">
        <pre terminal-code-command>CREATE TABLE MARCA (
  codigo INT not null primary key,
  nombre VARCHAR(20) not null,
  sede VARCHAR(20) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,01 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title"
        (click)="collapsedTables.createTableConcessionaire = !collapsedTables.createTableConcessionaire">
        CONCESIONARIO
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableConcessionaire}">
        <pre terminal-code-command>CREATE TABLE CONCESIONARIO (
  codigo INT not null primary key, 
  localidad VARCHAR(50) not null,
  hora_apertura TIME not null,
  hora_cierre TIME not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,03 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableClient = !collapsedTables.createTableClient">
        CLIENTE
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableClient}">
        <pre terminal-code-command>CREATE TABLE CLIENTE (
  dni VARCHAR(15) not null primary key,
  nombre VARCHAR(40) not null,
  fecha_nac DATE not null,
  telefono VARCHAR(15) not null
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,01 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableCar = !collapsedTables.createTableCar">
        COCHE
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableCar}">
        <pre terminal-code-command>CREATE TABLE COCHE (
  codigo INT not null primary key,
  cod_marca INT not null references MARCA(codigo) ON DELETE RESTRICT,
  modelo VARCHAR(60) not null,
  propulsion INT not null references PROPULSION(id) ON DELETE RESTRICT
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableOffer = !collapsedTables.createTableOffer">
        OFRECE
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableOffer}">
        <pre terminal-code-command>CREATE TABLE OFRECE (
  cod_coche INT not null references COCHE(codigo) ON DELETE RESTRICT,
  cod_concesionario INT not null references CONCESIONARIO(codigo) ON DELETE RESTRICT,
  cantidad INT check(cantidad > 0),
  primary key (cod_coche, cod_concesionario)
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableRepair = !collapsedTables.createTableRepair">
        REPARA
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableRepair}">
        <pre terminal-code-command>CREATE TABLE REPARA (
  id INT not null primary key,
  cod_mecanico INT not null references MECANICO(codigo) ON DELETE RESTRICT, 
  cod_coche INT not null references COCHE(codigo) ON DELETE RESTRICT,
  fecha INT not null,
  precio DECIMAL(10,2) not null check(precio > 0)
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,01 sec)</span>
      </app-terminal-code>
    </div>

    <div class="collapsible">
      <p class="collapsible__title" (click)="collapsedTables.createTableSale = !collapsedTables.createTableSale">
        VENTA
      </p>

      <app-terminal-code [ngClass]="{'app-terminal-code--expanded': !collapsedTables.createTableSale}">
        <pre terminal-code-command>CREATE TABLE VENTA (
  num_factura VARCHAR(15) not null primary key,
  cod_cliente VARCHAR(15) not null references CLIENTE(dni) ON DELETE RESTRICT,
  cod_coche INT not null,
  cod_concesionario INT not null,
  precio DECIMAL(10,2) not null check(precio > 100),
  fecha VARCHAR(30) not null,
  foreign key (cod_coche, cod_concesionario) references OFRECE(cod_coche, cod_concesionario)
);</pre>

        <span terminal-code-output>Query OK, 0 rows affected (0,02 sec)</span>
      </app-terminal-code>
    </div>

    <!-- TODO put link with scripts to create tables. ¿in a zip file? -->
  </section>

  <section>
    <h2>Alteración de tablas</h2>

    <p>
      A medida que vamos usando la base de datos y los requisitos de nuestra aplicación varian, puede que tengamos que
      cambiar restricciones, referencias, eliminar o añadir nuevas columnas, etc. Y eso es lo que vamos a ver antes de
      rellenar la base de datos por si te equivocaste al crear una de las tablas.
    </p>

    <p>
      Veamos como eliminar una tabla. Ten en cuenta que sólo se podrá eliminar si no está referenciada por ninguna otra
      tabla u objeto en la base de datos (en caso de haber puesto las restricciones oportunas).
    </p>

    <code>
      <pre class="command-sintax">DROP TABLE nombre_de_la_tabla</pre>
    </code>

    <p>
      Ahora veamos como añadir o eliminar una columna de una tabla, o sus restricciones:
    </p>

    <code>
      <pre class="command-sintax">ALTER TABLE nombreTabla
  ADD [COLUMN] especificaciónColumna,
  DROP [COLUMN] nombreColumna,
  ALTER [COLUMN] redefiniciónColumna,
  ADD CONSTRAINT nombreConstraint restriccionDeTabla,
  DROP CONSTRAINT nombreConstraint;</pre>
    </code>

    <p>



      <!-- TODO revisar este comentario. Si lo separamos por coma se puede hacer a la vez? -->



      Estas sentencias hay que ejecutarlas de una en una. No se puede añadir una columna a la vez que se elimina otra,
      por ejemplo. Para añadir una columna nueva la especificación de la columna es como cuando creamos una tabla. Y
      para eliminarla, simplemente indicamos el nombre. Si queremos redefinir la columna, es lo mismo, es como si
      estuvieramos definiéndola desde cero. Y con las restricciones de clave primaria, o foránea o un check es más de lo
      mismo, igual que si lo estuvieramos definiciendo como cuando creamos una tabla.
    </p>

    <p>
      Ahora veamos un ejemplo para cambiar el tipo de una columna.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>ALTER TABLE REPARA MODIFY fecha DATE default (CURRENT_DATE);</pre>

      <pre terminal-code-output>Query OK, 0 rows affected (0,03 sec)
Records: 0  Duplicates: 0  Warnings: 0</pre>
    </app-terminal-code>

    <p>
      En test caso, puesto que estamos modificando una columna existente y cambiando su tipo, usamos la palabra MODIFY.
      Después la sintaxis es la misma que ya hemos visto para definir una columna. Hay que tener en cuenta que al
      cambiar el tipo de dato podemos perder los valores de la columna si no son compatibles con el nuevo tipo. También
      puede que tengamos que eliminar primero ciertas restricciones antes de operar sobre la columna.
    </p>
  </section>

  <section>
    <h2>Rellenando la base de datos</h2>

    <p>
      Ahora sí ha llegado la hora de meter información en nuestra base de datos. Veamos la orden en general:
    </p>

    <code>
      <pre class="command-sintax">INSERT INTO tabla [(lista, de, columnas)] VALUES (lista, de, valores);</pre>
    </code>

    <p>
      La orden es muy sencillita. Especificamos las columnas que vamos a rellenar y sus valores. Entonces se creará una
      nueva fila en la tabla. Vamos a introducir algunas filas.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>INSERT INTO MARCA VALUES(1, 'Toyota', 'Japón');</pre>
      <pre terminal-code-output>Query OK, 1 row affected (0,01 sec)</pre>
    </app-terminal-code>

    <p>
      En este caso no he necesitado proporcionar el nombre de las columnas porque he proporcionado todos los valores en
      el orden que especificamos las columnas.
    </p>

    <app-terminal-code>
      <pre terminal-code-command>INSERT INTO COCHE VALUES(18, 2, 'Model', 1);</pre>
      <pre
        terminal-code-output>ERROR 1452 (23000): Cannot add or update a child row: a foreign key constraint fails (`business`.`COCHE`, CONSTRAINT `COCHE_ibfk_1` FOREIGN KEY (`cod_marca`) REFERENCES `MARCA` (`codigo`))</pre>
    </app-terminal-code>

    <p>
      En esta otra orden hemos intentado añadir un coche haciendo referencia a una marca que no existe, y tal es el caso
      que el sistema ha rechazado la transacción.
    </p>

    <p>
      Ahora para eliminar una fila de la tabla lo hacemos con esta otra orden:
    </p>

    <code>
      <pre class="command-sintax">DELETE FROM tabla WHERE condicion</pre>
    </code>

    <p>
      Es muy importante especificar la condición con la palabra WHERE. De otra forma <strong>se eliminarían todas las
        filas de la tabla.</strong>
    </p>
  </section>

  <section>
    <h2>La sentencia SELECT</h2>

    <p>
      Esta es la sentencia básica para recuperar datos de una base de datos. El formato de una consulta con esta
      sentencia es:
    </p>

    <code>
      <pre class="command-sintax">SELECT [ALL | DISTINCT]
expresión
FROM tabla
WHERE condición
GROUP BY columna 
HAVING condición 
ORDER BY columna/nº columna [ASC | DESC]</pre>
    </code>

    <p>
      La salida del comando es otra tabla con tantas filas como filas de la tabla a consultar cumplan la condición y
      tantas columnas como expresiones indiquemos.
    </p>

    <p>
      Con la orden SELECT indicamos que vamos a seleccionar datos de la tabla. La opción ALL es por defecto y significa
      que seleccione todas las filas aunque estén repetidas. Si ponemos DISTINCT la tabla de salida solo tendrá filas
      que no están repetidas (se eliminan las que están duplicadas).
    </p>

    <p>
      La segunda línea es una expresión. Podemos poner varias separadas por comas. Consiste en el nombre de una columna
      de la tabla, o expresiones matemáticas, o llamadas a funciones que manejen datos de tipo fecha o numérico o
      string. Podemos hacer que se concatenen columnas en una sola, y muchas más cosas.
    </p>

    <p>
      Con FROM indicamos la tabla de la cual vamos a seleccionar datos.
    </p>

    <p>
      Con WHERE podemos indicar las condiciones para seleccionar filas de la tabla. Podemos usar operadores lógicos
      (AND, OR y NOT), de comparación (=, &lt;&gt;, &lt;, &lt;=, &gt;,&gt;=) o predicados más avanzados (IN, BETWEEN,
      LIKE, IS NULL)
    </p>

    <p>
      Con GROUP BY podemos agrupar las filas resultantes en función de una de las columnas. Permite realizar operaciones
      de agregación, como sumas o promedios, por ejemplo. La tabla resultante tras usar esta cláusula, tiene una fila
      por cada grupo formado, es decir, por cada valor de la columnas o columnas. En el SELECT solo podremos tener
      columnas usadas en el GROUP BY y funciones.
    </p>

    <p>
      Con HAVING podemos filtrar los grupos con la condición indicada. Es igual que el WHERE, pero filtra grupos en vez
      de filas. La condición del WHERE se aplica a filas antes de agrupar, y el HAVING se aplica a grupos después de
      agrupar.
    </p>

    <p>
      Con ORDER BY podemos ordenar las filas de la tabla resultante de forma ascendente o descendente. Podemos hacerlo
      indicando el índice de una columna o su nombre. El nombre de la columna es el de la tabla original, o si es una
      columna compuesta (una expresión más compleja) podemos poner AS en la expresión para ponerle un nombre a la
      columna resultante.
    </p>
  </section>

  <section>
    <h2>Ejemplo básico de consulta</h2>

    <p>
      Para poner en práctica la sentencia SELECT voy a poner unos ejemplos de como usarla.
    </p>

    <p>
      Vamos a consultar todos los mecánicos que hay en la tabla MECANICO:
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT * from MECANICO;</span>
      <pre terminal-code-output>+--------+---------------------------------------+------------------------+
| codigo | nombre                                | ciudad                 |
+--------+---------------------------------------+------------------------+
|      1 | Mecánica Hábil Técnico                | Cuenca                 |
|      2 | Diagnóstico Hábil Total               | Burgos                 |
|      3 | Servicio Rápido Automotriz            | Zamora                 |
|      4 | Técnica Experto de Coches             | Almería                |
|      5 | Electromecánica Eficiente Express     | Girona                 |
|      6 | Mantenimiento Fiable de Coches        | Teruel                 |
|      7 | Técnica Preciso del Motor             | Castellón de la Plana  |
|      8 | Mecánica Innovador Mecánico           | Cáceres                |
|      9 | Electromecánica Innovador Automotriz  | Huelva                 |
|     10 | Neumáticos Eficiente Mantenimiento    | Lugo                   |
+--------+---------------------------------------+------------------------+
10 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      Si como expresión usamos el comodín (<strong>*</strong>) se seleccionan todas las columnas.
    </p>

    <p>
      Ahora vamos a seleccionar el nombre de las marcas que tienen sede en Alemania:
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT nombre FROM MARCA where sede="alemania" ORDER BY 1;</span>
      <pre terminal-code-output>+---------------+
| nombre        |
+---------------+
| Audi          |
| BMW           |
| Mercedes-Benz |
| Volkswagen    |
+---------------+
4 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      En esta otra sentencia la columna nos sale ordenada alfabéticamente al haber especificado el ORDER BY. Como sólo
      tenemos una columna en la salida, pues decimos que nos lo ordene por la primera columna, de ahí el 1.
    </p>

    <p>
      Ahora pidamos una consulta algo más compleja. Queremos saber la cantidad total de coches que ofrece cada
      concesionario.
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT cod_concesionario, sum(cantidad) as total_coches FROM OFRECE GROUP BY
        cod_concesionario ORDER BY 1;</span>
      <pre terminal-code-output>+-------------------+--------------+
| cod_concesionario | total_coches |
+-------------------+--------------+
|                 1 |         1629 |
|                 2 |         1515 |
|                 3 |         1002 |
|                 4 |         1594 |
|                 5 |         1302 |
|                 6 |         1397 |
|                 7 |         1335 |
|                 8 |         1664 |
|                 9 |          964 |
|                10 |         1193 |
|                11 |         1189 |
|                12 |         1283 |
|                13 |         1394 |
|                14 |         1317 |
|                15 |         1312 |
+-------------------+--------------+
15 rows in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      Esta tabla tiene dos columnas. La primera es parte de la tabla original, y la segunda la hemos puesto un alias
      <i>total_coches</i>, que es la suma de todas las cantidades por concesionario.
    </p>

    <p>
      Calculemos ahora la media de coches que ofrecen los concesionarios:
    </p>

    <app-terminal-code>
      <span terminal-code-command>SELECT floor(avg(total_coches)) as promedio FROM (SELECT cod_concesionario,
        sum(cantidad) as total_coches FROM OFRECE GROUP BY cod_concesionario ORDER BY 1) as T;</span>
      <pre terminal-code-output>+----------+
| promedio |
+----------+
|     1339 |
+----------+
1 row in set (0,00 sec)</pre>
    </app-terminal-code>

    <p>
      En esta ocasión hemos tenido que anidar dos sentencias y para ello he usado los paréntesis. Primero se obtiene la
      cantidad de coches de cada concesionario y sobre la tabla resultante, se calcula el promedio. Es obligatorio poner
      un alias a la tabla resultante anidada. En este caso simplemente la he llamado T.
    </p>
  </section>

  <section>
    <h2>El JOIN</h2>

    <p>
      Hasta ahora solo hemos hecho consultas que implicaban una tabla. ¿Pero que pasa si la información está distribuida
      por varias de ellas? Para eso usaremos el JOIN.
    </p>

    <p>
      El JOIN nos permite combinar las tablas que aparezcan en la cláusula FROM. La tabla resultante de la combinación
      es otra tabla resultado de aplicar el producto cartesiano de las tablas implicadas. Con esta imágen entenderemos
      mejor que es el producto cartesiano:
    </p>

    <img class="combination-table-image" src="pages-bbdd/assets/combination_table.png" alt="Combinación de tablas">

    <p>
      La orden para combinar las tablas sería así:
    </p>

    <code>
      <pre class="command-sintax">SELECT ta.c2, tb.c2, c5, ...
FROM tablaA ta, tablaB tb, tablaC
WHERE condición;</pre>
    </code>

    <p>
      En caso de que dos tablas tengan columnas con el mismo nombre, se deben usar alias para eliminar ambigüedades.
      En este ejemplo, ta y tb son alias para la tablaA y la tablaB. Los alias son opcionales en otras circunstancias.
    </p>

    <p>
      Es importante especificar una cláusula WHERE, ya que si no tendremos filas que no tendrán ningún sentido tras
      realizar el producto cartesiano, y obtendremos resultados que pueden ser incorrectos o confusos. El caso más
      habitual es igualar dos columnas entre dos tablas, aunque también se pueden usar otros operadores distintos al de
      la igualdad. En caso de relacionar más de dos tablas, recuerda que también se pueden usar condiciones AND y OR
      para relacionar las columnas de varias tablas mediante varias condiciones.
    </p>

    <p>
      Para poder separar las condiciones que combinan las tablas correctamente de las condiciones que queremos para
      seleccionar las filas de nuestra consulta, se puede usar la operación JOIN en el FROM, que da como resultado la
      tabla sobre la que se operará.
    </p>

    <code>
      <pre class="command-sintax">SELECT expresiones
FROM tabla1 [alias1] [INNER | LEFT | RIGHT | FULL | CROSS] JOIN tabla2 [alias2] ON condiciónDelJoin;
WHERE condiciónDeLaConsulta</pre>
    </code>

    <p>
      Existen varios tipos de JOIN. Vamos a explicarlos suponiendo que la condición es que C2 de la tabla A es igual a
      C2 de la tabla B.
    </p>

    <p>
      El <strong>INNER JOIN</strong> es el JOIN por defecto. Devuelve sólo las filas que cumplen la condición.
    </p>

    <img class="inner-join-image" src="pages-bbdd/assets/inner-join.png" alt="Inner join de tablas">

    <p>
      El <strong>LEFT JOIN</strong> devuelve todas las filas de la tabla de la izquierda (tabla A) y las que coinciden
      con la tabla derecha (tabla B). Si no hay coincidencias, se establece el valor a NULL en la tabla resultante.
    </p>

    <img class="left-join-image" src="pages-bbdd/assets/left-join.png" alt="Left join de tablas">

    <p>
      El <strong>RIGHT JOIN</strong> es igual que el LEFT JOIN, pero con la tabla de la derecha.
    </p>

    <img class="right-join-image" src="pages-bbdd/assets/right-join.png" alt="Right join de tablas">

    <p>
      El <strong>FULL JOIN</strong> es una combinación del LEFT JOIN y el RIGHT JOIN.
    </p>

    <img class="full-join-image" src="pages-bbdd/assets/full-join.png" alt="Full join de tablas">

    <p>
      Por último, el CROSS JOIN sería realizar el producto cartesiano, que es lo que habíamos visto al principio.
    </p>
  </section>
</main>